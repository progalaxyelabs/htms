# Generated Code API Reference

Understanding the code generated by HTMS compiler.

## Output Formats

HTMS can generate two different output formats:

1. **TypeScript** (default) - For dynamic web applications
2. **HTML** - For static websites

---

## TypeScript Output (Default)

When you compile with `htms compile app.htms -o dist/`, three files are generated:

### Generated Files

1. `templates.ts` - Component render functions
2. `router.ts` - Hash-based router with context management
3. `events.ts` - Event delegation and two-way binding

---

## templates.ts

Contains functions that create and return DOM elements.

### Type Definitions

```typescript
export type Context = Record<string, unknown>;
```

By default, context is loosely typed. You can provide better types in your `actions.ts`.

### Component Functions

Each component generates a function:

```typescript
export function ComponentName(ctx: Context): HTMLElement {
  // DOM creation code
}
```

**Example HTMS:**
```htms
component Button {
  button [class: "btn"] {
    {{ Click Me }}
  }
}
```

**Generated TypeScript:**
```typescript
export function Button(ctx: Context): HTMLElement {
  const el0 = document.createElement('button');
  el0.className = 'btn';
  const el1 = document.createTextNode('Click Me');
  el0.appendChild(el1);
  return el0;
}
```

### Component with Parameters

Components with parameters receive the parameter as second argument:

```htms
component UserCard(item: user) {
  div [class: "card"] {
    h3 {{ ${user.name} }}
  }
}
```

**Generated:**
```typescript
export function UserCard(ctx: Context, user: any): HTMLElement {
  const el0 = document.createElement('div');
  el0.className = 'card';
  const el1 = document.createElement('h3');
  const el2 = document.createTextNode(user.name);
  el1.appendChild(el2);
  el0.appendChild(el1);
  return el0;
}
```

### Page Functions

Pages also generate functions:

```htms
page home "/" {
  div {
    h1 {{ Welcome }}
  }
}
```

**Generated:**
```typescript
export function HomePage(ctx: Context): HTMLElement {
  const fragment = document.createDocumentFragment();
  const el0 = document.createElement('div');
  const el1 = document.createElement('h1');
  const el2 = document.createTextNode('Welcome');
  el1.appendChild(el2);
  el0.appendChild(el1);
  fragment.appendChild(el0);
  const root = document.createElement('div');
  root.appendChild(fragment);
  return root;
}
```

### Element Directives

Element directives generate separate reusable functions:

**HTMS with `@for`:**
```htms
ul @for(ctx.items as item) {
  li {{ ${item.name} }}
}
```

**Generated:**
```typescript
// Reusable function for list items
function renderItem_0(item: any, ctx: Context): HTMLElement {
  const el0 = document.createElement('li');
  const el1 = document.createTextNode(item.name);
  el0.appendChild(el1);
  return el0;
}

// Page function uses it
export function HomePage(ctx: Context): HTMLElement {
  const el0 = document.createElement('ul');
  ctx.items.forEach((item: any) => {
    el0.appendChild(renderItem_0(item, ctx));
  });
  return el0;
}
```

**HTMS with `@if`:**
```htms
div @if(ctx.showMessage) {
  p {{ ${ctx.message} }}
}
```

**Generated:**
```typescript
function renderConditional_0(ctx: Context): HTMLElement | null {
  if (ctx.showMessage) {
    const el0 = document.createElement('div');
    const el1 = document.createElement('p');
    const el2 = document.createTextNode(ctx.message);
    el1.appendChild(el2);
    el0.appendChild(el1);
    return el0;
  }
  return null;
}

export function HomePage(ctx: Context): HTMLElement {
  const fragment = document.createDocumentFragment();
  const conditionalEl = renderConditional_0(ctx);
  if (conditionalEl) {
    fragment.appendChild(conditionalEl);
  }
  // ...
}
```

---

## router.ts

Manages client-side routing and context.

### Imports

```typescript
import { Router } from './runtime';
import { HomePage, AboutPage } from './templates';
```

### Context Management

```typescript
// Application context
let context: Record<string, unknown> = {};
let currentPage: string = '';
const appContainer = document.getElementById('app');

export function getContext(): Record<string, unknown> {
  return context;
}

export function setContext(data: Record<string, unknown>): void {
  context = data;
}

export function rerender(): void {
  if (currentPage && appContainer) {
    const renderer = routes[currentPage];
    if (renderer) {
      appContainer.innerHTML = '';
      appContainer.appendChild(renderer(context));
    }
  }
}
```

### API Functions

#### `getContext()`

Returns the current application context.

```typescript
const ctx = getContext();
console.log(ctx.user);
```

#### `setContext(data)`

Sets the application context. Must be called before router initialization.

```typescript
setContext({
  user: { name: 'John' },
  posts: []
});
```

#### `rerender()`

Re-renders the current page with updated context. Call this after modifying context in event handlers.

```typescript
export const actions = {
  updateName: (ctx, event) => {
    ctx.data.user.name = 'Jane';
    ctx.rerender(); // Trigger re-render
  }
};
```

### Route Definitions

```typescript
const routes: Record<string, (ctx: Record<string, unknown>) => HTMLElement> = {
  '/': HomePage,
  '/about': AboutPage,
};
```

### Router Instance

```typescript
export const router = new Router({
  mode: 'hash',
  routes: {
    '/': () => renderPage('/'),
    '/about': () => renderPage('/about'),
  },
  notFound: () => renderPage('__404__'),
});
```

### Router Methods

#### `router.init()`

Initialize the router. Call this in your `main.ts`:

```typescript
import { router } from './dist/router';

router.init();
```

#### `router.navigate(path)`

Programmatically navigate to a route:

```typescript
router.navigate('/about');
```

---

## events.ts

Handles event delegation and two-way data binding.

### Imports

```typescript
import { getContext, setContext, rerender } from './router';
import { actions } from './actions';
```

### ActionContext Interface

```typescript
export interface ActionContext {
  data: Record<string, unknown>;
  rerender: () => void;
}
```

All event handlers receive this context.

### Initialization

```typescript
export function initEvents(): void {
  // Event delegation
  document.addEventListener('click', handleEvent);
  document.addEventListener('submit', handleEvent);
  document.addEventListener('input', handleEvent);
  document.addEventListener('change', handleEvent);
  document.addEventListener('blur', handleEvent, true);
  document.addEventListener('focus', handleEvent, true);

  // Two-way binding
  initBinding();
}
```

Call `initEvents()` in your `main.ts`:

```typescript
import { initEvents } from './dist/events';

initEvents();
```

### Event Handler Flow

When a user clicks a button with `onClick: handleClick`:

1. Generated code adds `data-action="handleClick"` attribute
2. Event delegation listener intercepts the click
3. Looks up `handleClick` in `actions` object
4. Calls the action with `ActionContext` and `Event`

### Two-way Binding

For inputs with `bind: ctx.form.email`:

1. Generated code adds `data-bind="form.email"` attribute
2. Binding listener intercepts `input` events
3. Automatically updates `ctx.form.email` with new value
4. No manual `ctx.rerender()` needed for input value

---

## runtime.ts

You need to provide a simple `Router` class. Example:

```typescript
export class Router {
  private routes: Record<string, () => void>;
  private notFound: () => void;

  constructor(config: {
    mode: 'hash';
    routes: Record<string, () => void>;
    notFound: () => void;
  }) {
    this.routes = config.routes;
    this.notFound = config.notFound;
  }

  init() {
    window.addEventListener('hashchange', () => this.handleRoute());
    this.handleRoute();
  }

  private handleRoute() {
    const hash = window.location.hash.slice(1) || '/';
    const handler = this.routes[hash] || this.notFound;
    handler();
  }

  navigate(path: string) {
    window.location.hash = `#${path}`;
  }
}
```

---

## actions.ts (User-Provided)

This file is **not generated**. You must create it.

### Structure

```typescript
export const actions = {
  actionName: (ctx, event) => {
    // Your logic here
  },

  actionWithParam: (param: any) => (ctx, event) => {
    // Curried function for parameters
  }
};
```

### Action Signature

```typescript
type Action = (ctx: ActionContext, event: Event) => void;
```

Where:
- `ctx.data` - Your application state
- `ctx.rerender()` - Function to re-render the page
- `event` - The DOM event (can call `preventDefault()`, etc.)

### Examples

**Simple action:**
```typescript
export const actions = {
  handleClick: (ctx, event) => {
    console.log('Clicked!');
    ctx.rerender();
  }
};
```

**Action with parameter:**
```typescript
export const actions = {
  deleteItem: (id: number) => (ctx, event) => {
    ctx.data.items = ctx.data.items.filter(item => item.id !== id);
    ctx.rerender();
  }
};
```

**Async action:**
```typescript
export const actions = {
  loadData: async (ctx, event) => {
    ctx.data.isLoading = true;
    ctx.rerender();

    try {
      const response = await fetch('/api/data');
      ctx.data.items = await response.json();
    } catch (error) {
      ctx.data.error = error.message;
    } finally {
      ctx.data.isLoading = false;
      ctx.rerender();
    }
  }
};
```

**Form submission:**
```typescript
export const actions = {
  handleSubmit: (ctx, event) => {
    event.preventDefault();

    const formData = {
      email: ctx.data.form.email,
      message: ctx.data.form.message
    };

    console.log('Submitting:', formData);
    ctx.data.form.submitted = true;
    ctx.rerender();
  }
};
```

---

## HTML Output

When you compile with `--format html`, HTMS generates a single HTML file.

### Generated Structure

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HTMS App</title>
</head>
<body>
  <div id="app"></div>

  <!-- Template for each page -->
  <template id="page-home">
    <!-- Page content -->
  </template>

  <template id="page-about">
    <!-- Page content -->
  </template>

  <script>
    // Router code
    // Template rendering code
  </script>
</body>
</html>
```

### Client-side Router

The generated HTML includes a simple hash-based router:

```javascript
const routes = {
  '/': () => renderTemplate('page-home'),
  '/about': () => renderTemplate('page-about')
};

function renderTemplate(id) {
  const template = document.getElementById(id);
  const content = template.content.cloneNode(true);
  const app = document.getElementById('app');
  app.innerHTML = '';
  app.appendChild(content);
}

function handleRoute() {
  const hash = window.location.hash.slice(1) || '/';
  const handler = routes[hash] || routes['/'];
  handler();
}

window.addEventListener('hashchange', handleRoute);
handleRoute();
```

### Layout Optimization

Components used in **all pages** are automatically hoisted to the persistent layout (outside templates):

```html
<body>
  <div id="app">
    <!-- NavBar rendered once -->
    <nav class="navbar">...</nav>

    <!-- Page-specific content swapped here -->
    <div id="page-content"></div>

    <!-- Footer rendered once -->
    <footer>...</footer>
  </div>
</body>
```

---

## Data Attributes

Generated elements use data attributes for functionality:

### Event Handling

```html
<button data-action="handleClick" data-event="click">
  Click Me
</button>

<form data-action="handleSubmit" data-event="submit" data-prevent="true">
  <!-- Form fields -->
</form>
```

Attributes:
- `data-action` - Action name from `actions.ts`
- `data-event` - Event type (`click`, `submit`, etc.)
- `data-prevent` - If `"true"`, calls `preventDefault()`
- `data-stop` - If `"true"`, calls `stopPropagation()`
- `data-once` - If `"true"`, removes handler after first trigger

### Event with Parameters

```html
<button
  data-action="deleteItem"
  data-event="click"
  data-args='[123]'>
  Delete
</button>
```

The `data-args` attribute contains JSON-encoded arguments.

### Two-way Binding

```html
<input
  type="text"
  value="initial value"
  data-bind="form.email">
```

The `data-bind` attribute contains the context path to update.

---

## TypeScript Type Safety

### Typing Context

Create an interface for your context:

```typescript
// types.ts
export interface AppContext {
  user: {
    id: number;
    name: string;
    email: string;
  };
  posts: Array<{
    id: number;
    title: string;
    content: string;
  }>;
  isLoading: boolean;
}
```

Use it in actions:

```typescript
import { AppContext } from './types';

type TypedActionContext = {
  data: AppContext;
  rerender: () => void;
};

export const actions = {
  updateUser: (ctx: TypedActionContext, event: Event) => {
    ctx.data.user.name = 'New Name'; // Fully typed!
    ctx.rerender();
  }
};
```

---

## Best Practices

### 1. Always Rerender After State Changes

```typescript
// ✅ Good
ctx.data.count++;
ctx.rerender();

// ❌ Bad (state updated but UI not refreshed)
ctx.data.count++;
```

### 2. Avoid Direct DOM Manipulation

Let HTMS handle the DOM:

```typescript
// ❌ Bad
document.getElementById('user-name').textContent = 'New Name';

// ✅ Good
ctx.data.user.name = 'New Name';
ctx.rerender();
```

### 3. Use Computed Values

```typescript
setContext({
  todos: [...],
  get activeTodos() {
    return this.todos.filter(t => !t.done);
  }
});
```

### 4. Debounce Expensive Operations

```typescript
let timer;
export const actions = {
  handleSearch: (ctx, event) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      // Perform search
      ctx.rerender();
    }, 300);
  }
};
```

---

## Next Steps

- [Component Patterns](/guide/component-patterns) - Best practices
- [Examples](/examples/) - Real-world applications
