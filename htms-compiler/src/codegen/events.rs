//! Events generator - generates minimal event handling code

use crate::ast::Program;
use crate::analyzer::SymbolTable;
use crate::GeneratedFile;
use super::utils::{analyze_events, EventAnalysis};

/// Generate events.ts based on actual usage
pub fn generate(program: &Program, _symbols: &SymbolTable) -> GeneratedFile {
    let analysis = analyze_events(program);
    let content = generate_events_code(&analysis);

    GeneratedFile {
        path: "events.ts".to_string(),
        content,
    }
}

fn generate_events_code(analysis: &EventAnalysis) -> String {
    let mut out = String::new();

    // Header
    out.push_str("// Generated by HTMS Compiler\n");
    out.push_str("// Do not edit manually\n\n");

    // Only import what we need
    if analysis.has_events || analysis.has_bindings {
        out.push_str("import { getContext, setContext, rerender } from './router';\n\n");
    }

    // Actions type and storage
    if analysis.has_events {
        out.push_str("type Actions = Record<string, (ctx: ActionContext, event: Event) => void>;\n");
        out.push_str("let actions: Actions = {};\n\n");
        out.push_str("export function setActions(a: Actions): void {\n");
        out.push_str("  actions = a;\n");
        out.push_str("}\n\n");
        out.push_str("export interface ActionContext {\n");
        out.push_str("  data: Record<string, unknown>;\n");
        out.push_str("  rerender: () => void;\n");
        out.push_str("}\n\n");
    }

    // Init function
    out.push_str("export function initEvents(): void {\n");

    if analysis.has_events {
        // Only register listeners for event types actually used
        for event_type in &analysis.event_types {
            let use_capture = event_type == "blur" || event_type == "focus";
            if use_capture {
                out.push_str(&format!(
                    "  document.addEventListener('{}', handleEvent, true);\n",
                    event_type
                ));
            } else {
                out.push_str(&format!(
                    "  document.addEventListener('{}', handleEvent);\n",
                    event_type
                ));
            }
        }
    }

    if analysis.has_bindings {
        out.push_str("  initBinding();\n");
    }

    out.push_str("}\n");

    // handleEvent function - only if events are used
    if analysis.has_events {
        out.push_str("\n");
        out.push_str("function handleEvent(event: Event): void {\n");
        out.push_str("  const target = event.target as HTMLElement;\n");
        out.push_str("  const actionEl = target.closest('[data-action]') as HTMLElement;\n");
        out.push_str("  if (!actionEl) return;\n\n");
        out.push_str("  const actionName = actionEl.dataset.action;\n");
        out.push_str("  const eventType = actionEl.dataset.event;\n");
        out.push_str("  if (eventType && eventType !== event.type) return;\n\n");
        out.push_str("  if (actionEl.dataset.prevent === 'true') event.preventDefault();\n");
        out.push_str("  if (actionEl.dataset.stop === 'true') event.stopPropagation();\n\n");
        out.push_str("  const action = actions[actionName!];\n");
        out.push_str("  if (action) {\n");
        out.push_str("    const ctx: ActionContext = {\n");
        out.push_str("      data: getContext(),\n");
        out.push_str("      rerender: () => { setContext(ctx.data); rerender(); }\n");
        out.push_str("    };\n");
        out.push_str("    action(ctx, event);\n");
        out.push_str("    if (actionEl.dataset.once === 'true') actionEl.removeAttribute('data-action');\n");
        out.push_str("  }\n");
        out.push_str("}\n");
    }

    // Binding functions - only if bindings are used
    if analysis.has_bindings {
        out.push_str("\n");
        out.push_str("function initBinding(): void {\n");
        out.push_str("  document.addEventListener('input', (e) => {\n");
        out.push_str("    const el = e.target as HTMLInputElement;\n");
        out.push_str("    const bindPath = el.dataset.bind;\n");
        out.push_str("    if (bindPath) {\n");
        out.push_str("      const ctx = getContext();\n");
        out.push_str("      setNestedValue(ctx, bindPath, el.value);\n");
        out.push_str("      setContext(ctx);\n");
        out.push_str("    }\n");
        out.push_str("  });\n");
        out.push_str("  document.addEventListener('change', (e) => {\n");
        out.push_str("    const el = e.target as HTMLInputElement;\n");
        out.push_str("    const bindPath = el.dataset.bind;\n");
        out.push_str("    if (bindPath && el.type === 'checkbox') {\n");
        out.push_str("      const ctx = getContext();\n");
        out.push_str("      setNestedValue(ctx, bindPath, el.checked);\n");
        out.push_str("      setContext(ctx);\n");
        out.push_str("    }\n");
        out.push_str("  });\n");
        out.push_str("}\n\n");
        out.push_str("function setNestedValue(obj: Record<string, unknown>, path: string, value: unknown): void {\n");
        out.push_str("  const keys = path.split('.');\n");
        out.push_str("  const last = keys.pop()!;\n");
        out.push_str("  let current: Record<string, unknown> = obj;\n");
        out.push_str("  for (const k of keys) {\n");
        out.push_str("    if (!current[k] || typeof current[k] !== 'object') current[k] = {};\n");
        out.push_str("    current = current[k] as Record<string, unknown>;\n");
        out.push_str("  }\n");
        out.push_str("  current[last] = value;\n");
        out.push_str("}\n");
    }

    out
}
