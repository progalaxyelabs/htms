//! Template function generator
//!
//! Generates TypeScript functions that return DOM elements.
//! No innerHTML, no template strings - pure DOM API.

use crate::ast::*;
use crate::analyzer::SymbolTable;
use crate::GeneratedFile;
use super::utils;

/// Generate templates.ts
pub fn generate(program: &Program, _symbols: &SymbolTable) -> GeneratedFile {
    let mut gen = TemplateGenerator::new();
    gen.generate(program);

    GeneratedFile {
        path: "templates.ts".to_string(),
        content: gen.output,
    }
}

struct TemplateGenerator {
    output: String,
    indent: usize,
    var_counter: usize,
    has_events: bool,
}

impl TemplateGenerator {
    fn new() -> Self {
        Self {
            output: String::new(),
            indent: 0,
            var_counter: 0,
            has_events: false,
        }
    }

    fn next_var(&mut self) -> String {
        let var = format!("el{}", self.var_counter);
        self.var_counter += 1;
        var
    }

    fn reset_vars(&mut self) {
        self.var_counter = 0;
    }

    fn generate(&mut self, program: &Program) {
        // First pass: check if we have any events
        self.has_events = utils::program_has_events(program);

        // Header
        self.writeln("// Generated by HTMS Compiler");
        self.writeln("// Do not edit manually");
        self.writeln("");
        if self.has_events {
            self.writeln("import { actions } from './actions';");
            self.writeln("");
        }
        self.writeln("export type Context = Record<string, unknown>;");
        self.writeln("");

        // Generate each declaration
        for decl in &program.body {
            match decl {
                Declaration::Component(c) => self.generate_component(c),
                Declaration::Section(s) => self.generate_section(s),
                Declaration::Page(p) => self.generate_page(p),
            }
            self.writeln("");
        }
    }

    fn generate_component(&mut self, comp: &ComponentDecl) {
        self.reset_vars();

        // Function signature
        if comp.parameters.is_empty() {
            self.writeln(&format!(
                "export function {}(ctx: Context): HTMLElement {{",
                comp.name
            ));
        } else {
            let params: Vec<String> = comp.parameters
                .iter()
                .map(|p| format!("{}: unknown", p.binding))
                .collect();
            self.writeln(&format!(
                "export function {}(ctx: Context, {}): HTMLElement {{",
                comp.name,
                params.join(", ")
            ));
        }

        self.indent += 1;

        // Create root fragment if multiple children
        if comp.body.len() == 1 {
            let root_var = self.generate_node(&comp.body[0], None);
            self.writeln(&format!("return {};", root_var));
        } else {
            self.writeln("const fragment = document.createDocumentFragment();");
            for node in &comp.body {
                let var = self.generate_node(node, None);
                self.writeln(&format!("fragment.appendChild({});", var));
            }
            // Wrap in a div since we need to return HTMLElement
            self.writeln("const root = document.createElement('div');");
            self.writeln("root.appendChild(fragment);");
            self.writeln("return root;");
        }

        self.indent -= 1;
        self.writeln("}");
    }

    fn generate_section(&mut self, section: &SectionDecl) {
        self.reset_vars();

        self.writeln(&format!(
            "export function {}(ctx: Context): HTMLElement {{",
            section.name
        ));

        self.indent += 1;

        if section.body.len() == 1 {
            let root_var = self.generate_node(&section.body[0], None);
            self.writeln(&format!("return {};", root_var));
        } else {
            self.writeln("const fragment = document.createDocumentFragment();");
            for node in &section.body {
                let var = self.generate_node(node, None);
                self.writeln(&format!("fragment.appendChild({});", var));
            }
            self.writeln("const root = document.createElement('div');");
            self.writeln("root.appendChild(fragment);");
            self.writeln("return root;");
        }

        self.indent -= 1;
        self.writeln("}");
    }

    fn generate_page(&mut self, page: &PageDecl) {
        self.reset_vars();

        self.writeln(&format!(
            "export function {}Page(ctx: Context): HTMLElement {{",
            capitalize(&page.name)
        ));

        self.indent += 1;

        if page.body.len() == 1 {
            let root_var = self.generate_node(&page.body[0], None);
            self.writeln(&format!("return {};", root_var));
        } else {
            self.writeln("const fragment = document.createDocumentFragment();");
            for node in &page.body {
                let var = self.generate_node(node, None);
                self.writeln(&format!("fragment.appendChild({});", var));
            }
            self.writeln("const root = document.createElement('div');");
            self.writeln("root.appendChild(fragment);");
            self.writeln("return root;");
        }

        self.indent -= 1;
        self.writeln("}");
    }

    /// Generate a node and return the variable name
    fn generate_node(&mut self, node: &Node, parent_var: Option<&str>) -> String {
        match node {
            Node::Element(el) => self.generate_element(el, parent_var),
            Node::ComponentRef(r) => self.generate_component_ref(r, parent_var),
            Node::Text(t) => self.generate_text(t, parent_var),
            Node::If(stmt) => self.generate_if(stmt, parent_var),
            Node::Each(stmt) => self.generate_each(stmt, parent_var),
            Node::Slot(_) => {
                // Slots are handled at component call site
                let var = self.next_var();
                self.writeln(&format!("const {} = document.createComment('slot');", var));
                var
            }
        }
    }

    fn generate_element(&mut self, el: &Element, _parent: Option<&str>) -> String {
        let var = self.next_var();

        // Create element
        self.writeln(&format!(
            "const {} = document.createElement('{}');",
            var, el.tag
        ));

        // Set attributes
        for attr in &el.attributes {
            self.generate_attribute(&var, attr);
        }

        // Add children
        for child in &el.children {
            let child_var = self.generate_node(child, Some(&var));
            self.writeln(&format!("{}.appendChild({});", var, child_var));
        }

        var
    }

    fn generate_attribute(&mut self, el_var: &str, attr: &Attribute) {
        let name = &attr.name;

        // Check for event handlers
        if name.starts_with("on") {
            self.generate_event_attribute(el_var, attr);
            return;
        }

        // Check for bind
        if name == "bind" {
            self.generate_bind_attribute(el_var, attr);
            return;
        }

        // Handle class specially
        if name == "class" {
            match &attr.value {
                Expression::String(s) => {
                    self.writeln(&format!("{}.className = '{}';", el_var, s.value));
                }
                Expression::ContextPath(p) => {
                    let path = strip_ctx(&p.path);
                    self.writeln(&format!("{}.className = String(ctx.{});", el_var, path));
                }
                Expression::Ternary(t) => {
                    let cond = self.expr_to_js(&t.condition);
                    let cons = self.expr_to_js(&t.consequent);
                    let alt = self.expr_to_js(&t.alternate);
                    self.writeln(&format!(
                        "{}.className = {} ? {} : {};",
                        el_var, cond, cons, alt
                    ));
                }
                _ => {
                    let val = self.expr_to_js(&attr.value);
                    self.writeln(&format!("{}.className = {};", el_var, val));
                }
            }
            return;
        }

        // Handle id
        if name == "id" {
            match &attr.value {
                Expression::String(s) => {
                    self.writeln(&format!("{}.id = '{}';", el_var, s.value));
                }
                _ => {
                    let val = self.expr_to_js(&attr.value);
                    self.writeln(&format!("{}.id = {};", el_var, val));
                }
            }
            return;
        }

        // Handle boolean attributes
        if let Expression::Boolean(b) = &attr.value {
            if b.value {
                self.writeln(&format!("{}.setAttribute('{}', '');", el_var, name));
            }
            return;
        }

        // Handle href, src, etc. as properties
        let prop_attrs = ["href", "src", "value", "type", "name", "placeholder", "alt", "title"];
        if prop_attrs.contains(&name.as_str()) {
            match &attr.value {
                Expression::String(s) => {
                    self.writeln(&format!("{}.{} = '{}';", el_var, name, s.value));
                }
                Expression::ContextPath(p) => {
                    let path = strip_ctx(&p.path);
                    self.writeln(&format!("{}.{} = String(ctx.{});", el_var, name, path));
                }
                _ => {
                    let val = self.expr_to_js(&attr.value);
                    self.writeln(&format!("{}.{} = {};", el_var, name, val));
                }
            }
            return;
        }

        // General setAttribute
        match &attr.value {
            Expression::String(s) => {
                self.writeln(&format!("{}.setAttribute('{}', '{}');", el_var, name, s.value));
            }
            Expression::Number(n) => {
                self.writeln(&format!("{}.setAttribute('{}', '{}');", el_var, name, n.value));
            }
            Expression::ContextPath(p) => {
                let path = strip_ctx(&p.path);
                self.writeln(&format!(
                    "{}.setAttribute('{}', String(ctx.{}));",
                    el_var, name, path
                ));
            }
            _ => {
                let val = self.expr_to_js(&attr.value);
                self.writeln(&format!("{}.setAttribute('{}', String({}));", el_var, name, val));
            }
        }
    }

    fn generate_event_attribute(&mut self, el_var: &str, attr: &Attribute) {
        // Parse event name and modifiers: onClick.prevent -> click, [prevent]
        let parts: Vec<&str> = attr.name.split('.').collect();
        let event_name = parts[0].strip_prefix("on").unwrap_or(parts[0]).to_lowercase();
        let modifiers: Vec<&str> = parts[1..].to_vec();

        // Extract action name and args
        let (action, args) = match &attr.value {
            Expression::Identifier(id) => (id.name.clone(), Vec::new()),
            Expression::Call(c) => (c.callee.clone(), c.arguments.clone()),
            _ => return,
        };

        // Build event handler
        self.writeln(&format!("{}.addEventListener('{}', (e) => {{", el_var, event_name));
        self.indent += 1;

        // Apply modifiers
        if modifiers.contains(&"prevent") {
            self.writeln("e.preventDefault();");
        }
        if modifiers.contains(&"stop") {
            self.writeln("e.stopPropagation();");
        }

        // Call action
        if args.is_empty() {
            self.writeln(&format!("actions.{}(ctx, e);", action));
        } else {
            let args_str: Vec<String> = args.iter()
                .map(|a| self.expr_to_js(a))
                .collect();
            self.writeln(&format!(
                "actions.{}({})(({{ data: ctx, rerender: () => {{}} }}), e);",
                action,
                args_str.join(", ")
            ));
        }

        self.indent -= 1;
        self.writeln("});");

        // Handle once modifier
        if modifiers.contains(&"once") {
            self.writeln(&format!(
                "// Note: 'once' modifier - consider using {{ once: true }} option",
            ));
        }
    }

    fn generate_bind_attribute(&mut self, el_var: &str, attr: &Attribute) {
        if let Expression::ContextPath(p) = &attr.value {
            let path = strip_ctx(&p.path);

            // Set initial value
            self.writeln(&format!("{}.value = String(ctx.{} || '');", el_var, path));

            // Add input listener for two-way binding
            self.writeln(&format!("{}.addEventListener('input', (e) => {{", el_var));
            self.indent += 1;
            self.writeln(&format!(
                "setNestedValue(ctx, '{}', (e.target as HTMLInputElement).value);",
                path
            ));
            self.indent -= 1;
            self.writeln("});");
        }
    }

    fn generate_component_ref(&mut self, r: &ComponentRef, _parent: Option<&str>) -> String {
        let var = self.next_var();

        if r.parameters.is_empty() {
            self.writeln(&format!("const {} = {}(ctx);", var, r.name));
        } else {
            let params: Vec<String> = r.parameters.iter()
                .map(|p| self.expr_to_js(&p.value))
                .collect();
            self.writeln(&format!(
                "const {} = {}(ctx, {});",
                var, r.name, params.join(", ")
            ));
        }

        var
    }

    fn generate_text(&mut self, text: &TextNode, _parent: Option<&str>) -> String {
        let var = self.next_var();

        // Check if text contains ${...} interpolation patterns
        let content = &text.content;

        // Debug: print content for troubleshooting
        // eprintln!("Text content: {:?}", content);

        if content.contains("${") {
            // Parse and handle variable interpolation
            let generated = self.interpolate_variables(content);
            self.writeln(&format!(
                "const {} = document.createTextNode({});",
                var, generated
            ));
        } else {
            // Pure literal text - escape single quotes
            let escaped = content.replace('\\', "\\\\").replace('\'', "\\'");
            self.writeln(&format!(
                "const {} = document.createTextNode('{}');",
                var, escaped
            ));
        }

        var
    }

    fn interpolate_variables(&self, text: &str) -> String {
        use regex::Regex;

        // Regex to match ${ctx.foo.bar}, ${varname}, or ${item.property}
        // Allows: ctx.path, identifier, or identifier.path
        let re = Regex::new(r"\$\{([a-zA-Z_][a-zA-Z0-9_]*(?:\.[a-zA-Z0-9_.]+)?)\}").unwrap();

        let mut parts = Vec::new();
        let mut last_end = 0;

        for cap in re.captures_iter(text) {
            let full_match = cap.get(0).unwrap();
            let var_path = cap.get(1).unwrap().as_str();

            // Add literal text before this variable
            if full_match.start() > last_end {
                let literal = &text[last_end..full_match.start()];
                let escaped = literal.replace('\\', "\\\\").replace('\'', "\\'");
                parts.push(format!("'{}'", escaped));
            }

            // Add variable with null coalescing
            parts.push(format!("String({} ?? 'null')", var_path));

            last_end = full_match.end();
        }

        // Add remaining literal text
        if last_end < text.len() {
            let literal = &text[last_end..];
            let escaped = literal.replace('\\', "\\\\").replace('\'', "\\'");
            parts.push(format!("'{}'", escaped));
        }

        // Join with +
        if parts.is_empty() {
            // No variables matched, treat entire text as literal
            let escaped = text.replace('\\', "\\\\").replace('\'', "\\'");
            format!("'{}'", escaped)
        } else if parts.len() == 1 {
            parts[0].clone()
        } else {
            parts.join(" + ")
        }
    }

    fn generate_if(&mut self, stmt: &IfStatement, _parent: Option<&str>) -> String {
        let var = self.next_var();
        let cond = self.expr_to_js(&stmt.condition);

        // Create a placeholder/container
        self.writeln(&format!("let {}: Node;", var));
        self.writeln(&format!("if ({}) {{", cond));

        self.indent += 1;
        if stmt.consequent.len() == 1 {
            let child_var = self.generate_node(&stmt.consequent[0], None);
            self.writeln(&format!("{} = {};", var, child_var));
        } else {
            self.writeln("const fragment = document.createDocumentFragment();");
            for node in &stmt.consequent {
                let child_var = self.generate_node(node, None);
                self.writeln(&format!("fragment.appendChild({});", child_var));
            }
            self.writeln(&format!("{} = fragment;", var));
        }
        self.indent -= 1;

        match &stmt.alternate {
            Some(Alternate::Block(nodes)) => {
                self.writeln("} else {");
                self.indent += 1;
                if nodes.len() == 1 {
                    let child_var = self.generate_node(&nodes[0], None);
                    self.writeln(&format!("{} = {};", var, child_var));
                } else {
                    self.writeln("const fragment = document.createDocumentFragment();");
                    for node in nodes {
                        let child_var = self.generate_node(node, None);
                        self.writeln(&format!("fragment.appendChild({});", child_var));
                    }
                    self.writeln(&format!("{} = fragment;", var));
                }
                self.indent -= 1;
                self.writeln("}");
            }
            Some(Alternate::ElseIf(elif)) => {
                let elif_cond = self.expr_to_js(&elif.condition);
                self.writeln(&format!("}} else if ({}) {{", elif_cond));
                self.indent += 1;
                if elif.consequent.len() == 1 {
                    let child_var = self.generate_node(&elif.consequent[0], None);
                    self.writeln(&format!("{} = {};", var, child_var));
                } else {
                    self.writeln("const fragment = document.createDocumentFragment();");
                    for node in &elif.consequent {
                        let child_var = self.generate_node(node, None);
                        self.writeln(&format!("fragment.appendChild({});", child_var));
                    }
                    self.writeln(&format!("{} = fragment;", var));
                }
                self.indent -= 1;
                self.writeln("} else {");
                self.indent += 1;
                self.writeln(&format!("{} = document.createComment('');", var));
                self.indent -= 1;
                self.writeln("}");
            }
            None => {
                self.writeln("} else {");
                self.indent += 1;
                self.writeln(&format!("{} = document.createComment('');", var));
                self.indent -= 1;
                self.writeln("}");
            }
        }

        var
    }

    fn generate_each(&mut self, stmt: &EachStatement, _parent: Option<&str>) -> String {
        let var = self.next_var();
        let iterable = self.expr_to_js(&stmt.iterable);
        let item = &stmt.item_name;

        self.writeln(&format!("const {} = document.createDocumentFragment();", var));

        if let Some(index) = &stmt.index_name {
            self.writeln(&format!(
                "({} as unknown[]).forEach(({}, {}) => {{",
                iterable, item, index
            ));
        } else {
            self.writeln(&format!(
                "for (const {} of ({} as unknown[])) {{",
                item, iterable
            ));
        }

        self.indent += 1;
        for node in &stmt.body {
            let child_var = self.generate_node(node, None);
            self.writeln(&format!("{}.appendChild({});", var, child_var));
        }
        self.indent -= 1;

        if stmt.index_name.is_some() {
            self.writeln("});");
        } else {
            self.writeln("}");
        }

        var
    }

    // =========================================================================
    // Expression to JS
    // =========================================================================

    fn expr_to_js(&self, expr: &Expression) -> String {
        match expr {
            Expression::String(s) => format!("'{}'", s.value.replace('\'', "\\'")),
            Expression::Number(n) => format!("{}", n.value),
            Expression::Boolean(b) => format!("{}", b.value),
            Expression::ContextPath(p) => format!("ctx.{}", strip_ctx(&p.path)),
            Expression::Identifier(id) => id.name.clone(),
            Expression::MemberAccess(m) => {
                let obj = self.expr_to_js(&m.object);
                format!("{}.{}", obj, m.property)
            }
            Expression::Binary(b) => {
                let left = self.expr_to_js(&b.left);
                let right = self.expr_to_js(&b.right);
                let op = match b.operator {
                    BinaryOp::Eq => "===",
                    BinaryOp::Ne => "!==",
                    BinaryOp::Lt => "<",
                    BinaryOp::Le => "<=",
                    BinaryOp::Gt => ">",
                    BinaryOp::Ge => ">=",
                    BinaryOp::And => "&&",
                    BinaryOp::Or => "||",
                    BinaryOp::Add => "+",
                    BinaryOp::Sub => "-",
                    BinaryOp::Mul => "*",
                    BinaryOp::Div => "/",
                };
                format!("({} {} {})", left, op, right)
            }
            Expression::Ternary(t) => {
                let cond = self.expr_to_js(&t.condition);
                let cons = self.expr_to_js(&t.consequent);
                let alt = self.expr_to_js(&t.alternate);
                format!("({} ? {} : {})", cond, cons, alt)
            }
            Expression::Call(c) => {
                let args: Vec<String> = c.arguments.iter()
                    .map(|a| self.expr_to_js(a))
                    .collect();
                format!("{}({})", c.callee, args.join(", "))
            }
            Expression::Event(_) => String::new(),
        }
    }

    // =========================================================================
    // Helpers
    // =========================================================================

    fn writeln(&mut self, s: &str) {
        if !s.is_empty() {
            for _ in 0..self.indent {
                self.output.push_str("  ");
            }
            self.output.push_str(s);
        }
        self.output.push('\n');
    }
}

fn strip_ctx(path: &str) -> &str {
    path.strip_prefix("ctx.").unwrap_or(path)
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    match chars.next() {
        None => String::new(),
        Some(c) => c.to_uppercase().collect::<String>() + chars.as_str(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer::tokenize;
    use crate::parser::parse;
    use crate::analyzer::analyze;

    fn generate_templates(source: &str) -> String {
        let tokens = tokenize(source).unwrap();
        let ast = parse(&tokens).unwrap();
        let (symbols, _) = analyze(&ast);
        let file = generate(&ast, &symbols);
        file.content
    }

    #[test]
    fn test_simple_component() {
        let output = generate_templates(r#"
            component NavBar {
                nav [class: "navbar"] { }
            }
        "#);

        assert!(output.contains("export function NavBar"));
        assert!(output.contains("document.createElement('nav')"));
        assert!(output.contains(".className = 'navbar'"));
    }

    #[test]
    fn test_text_shorthand() {
        let output = generate_templates(r#"
            component Button {
                button [onClick: submit] {{ Send }}
            }
        "#);

        assert!(output.contains("document.createTextNode('Send')"));
        assert!(output.contains("addEventListener('click'"));
    }

    #[test]
    fn test_dynamic_content() {
        let output = generate_templates(r#"
            component Title {
                h1 { {{ ${ctx.title} }} }
            }
        "#);

        assert!(output.contains("document.createTextNode(String(ctx.title ?? 'null'))"));
    }

    #[test]
    fn test_literal_text_with_quotes() {
        let output = generate_templates(r#"
            component Hello {
                p { {{ "Hello World" }} }
            }
        "#);

        assert!(output.contains("document.createTextNode('\"Hello World\"')"));
    }

    #[test]
    fn test_variable_interpolation() {
        let output = generate_templates("component Stats { p { {{ Total: ${ctx.count} items }} } }");

        assert!(output.contains("'Total: ' + String(ctx.count ?? 'null') + ' items'"));
    }

    #[test]
    fn test_escaped_single_quotes() {
        let output = generate_templates(r#"
            component Message {
                p { {{ She said 'hello' }} }
            }
        "#);

        assert!(output.contains(r"createTextNode('She said \'hello\'')"));
    }

    #[test]
    fn test_literal_variable_name() {
        let output = generate_templates(r#"
            component Literal {
                p { {{ ctx.message }} }
            }
        "#);

        assert!(output.contains("createTextNode('ctx.message')"));
    }

    #[test]
    fn test_multiple_interpolations() {
        let output = generate_templates(r#"
            component User {
                p { {{ Hello ${ctx.name}, you have ${ctx.count} messages }} }
            }
        "#);

        assert!(output.contains("'Hello ' + String(ctx.name ?? 'null') + ', you have ' + String(ctx.count ?? 'null') + ' messages'"));
    }

    #[test]
    fn test_invalid_interpolation_pattern() {
        let output = generate_templates(r#"
            component CSS {
                p { {{ Use var(${--color}) for CSS }} }
            }
        "#);

        // Invalid pattern should be treated as literal
        assert!(output.contains("createTextNode('Use var(${--color}) for CSS')"));
    }

    #[test]
    fn test_each_statement() {
        let output = generate_templates(r#"
            component List {
                ul {
                    @each ctx.items as item {
                        li { item.name }
                    }
                }
            }
        "#);

        assert!(output.contains("createDocumentFragment"));
        assert!(output.contains("for (const item of"));
    }
}
