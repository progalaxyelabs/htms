//! Token definitions for HTMS

use logos::Logos;
use crate::Location;

/// Token with location information
#[derive(Debug, Clone)]
pub struct Token {
    pub kind: TokenKind,
    pub value: String,
    pub location: Location,
}

/// Token types generated by the lexer
#[derive(Logos, Debug, Clone, Copy, PartialEq, Eq)]
#[logos(skip r"[ \t\r]+")]  // Skip whitespace (but not newlines)
pub enum TokenKind {
    // =========================================================================
    // Keywords
    // =========================================================================
    #[token("component")]
    Component,

    #[token("section")]
    Section,

    #[token("page")]
    Page,

    #[token("as")]
    As,

    #[token("true")]
    True,

    #[token("false")]
    False,

    // =========================================================================
    // Directives
    // =========================================================================
    #[token("@if")]
    If,

    #[token("@else")]
    Else,

    #[token("@each")]
    Each,

    #[token("@slot")]
    Slot,

    // =========================================================================
    // Punctuation
    // =========================================================================
    #[token("[")]
    LBracket,

    #[token("]")]
    RBracket,

    #[token("{")]
    LBrace,

    #[token("}")]
    RBrace,

    #[token("(")]
    LParen,

    #[token(")")]
    RParen,

    #[token(":")]
    Colon,

    #[token(",")]
    Comma,

    #[token(".")]
    Dot,

    #[token("?")]
    Question,

    #[token("{{")]
    TextOpen,

    #[token("}}")]
    TextClose,

    #[token("${")]
    InterpolationStart,

    // =========================================================================
    // Operators
    // =========================================================================
    #[token("==")]
    Eq,

    #[token("!=")]
    Ne,

    #[token(">=")]
    Ge,

    #[token("<=")]
    Le,

    #[token(">")]
    Gt,

    #[token("<")]
    Lt,

    #[token("&&")]
    And,

    #[token("||")]
    Or,

    #[token("!")]
    Not,

    #[token("+")]
    Plus,

    #[token("-")]
    Minus,

    #[token("*")]
    Star,

    #[token("/")]
    Slash,

    // =========================================================================
    // Literals and Identifiers
    // =========================================================================
    /// String literal: "..." or '...'
    #[regex(r#""[^"]*""#)]
    #[regex(r#"'[^']*'"#)]
    String,

    /// Number literal: 123, 3.14
    #[regex(r"[0-9]+(\.[0-9]+)?")]
    Number,

    /// Context path: ctx.user.name
    #[regex(r"ctx(\.[a-zA-Z_][a-zA-Z0-9_]*)+")]
    ContextPath,

    /// Identifier (lowercase start): div, span, myAction
    #[regex(r"[a-z][a-zA-Z0-9_-]*")]
    Identifier,

    /// Component name (uppercase start): NavBar, UserCard
    #[regex(r"[A-Z][a-zA-Z0-9]*")]
    ComponentName,

    // =========================================================================
    // Comments and Whitespace
    // =========================================================================
    /// Single-line comment: // ...
    #[regex(r"//[^\n]*")]
    LineComment,

    /// Block comment: /* ... */
    #[regex(r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/")]
    BlockComment,

    /// Newline (tracked for line counting)
    #[token("\n")]
    Newline,

    // =========================================================================
    // Special
    // =========================================================================
    /// Text content between {{ and }}
    TextContent,

    /// End of file
    Eof,
}

impl TokenKind {
    /// Check if this token is a comment
    pub fn is_comment(&self) -> bool {
        matches!(self, TokenKind::LineComment | TokenKind::BlockComment)
    }

    /// Check if this token is whitespace/newline
    pub fn is_whitespace(&self) -> bool {
        matches!(self, TokenKind::Newline)
    }

    /// Human-readable name for error messages
    pub fn name(&self) -> &'static str {
        match self {
            TokenKind::Component => "'component'",
            TokenKind::Section => "'section'",
            TokenKind::Page => "'page'",
            TokenKind::As => "'as'",
            TokenKind::True => "'true'",
            TokenKind::False => "'false'",
            TokenKind::If => "'@if'",
            TokenKind::Else => "'@else'",
            TokenKind::Each => "'@each'",
            TokenKind::Slot => "'@slot'",
            TokenKind::LBracket => "'['",
            TokenKind::RBracket => "']'",
            TokenKind::LBrace => "'{'",
            TokenKind::RBrace => "'}'",
            TokenKind::LParen => "'('",
            TokenKind::RParen => "')'",
            TokenKind::Colon => "':'",
            TokenKind::Comma => "','",
            TokenKind::Dot => "'.'",
            TokenKind::Question => "'?'",
            TokenKind::TextOpen => "'{{'",
            TokenKind::TextClose => "'}}'",
            TokenKind::InterpolationStart => "'${'",
            TokenKind::Eq => "'=='",
            TokenKind::Ne => "'!='",
            TokenKind::Ge => "'>='",
            TokenKind::Le => "'<='",
            TokenKind::Gt => "'>'",
            TokenKind::Lt => "'<'",
            TokenKind::And => "'&&'",
            TokenKind::Or => "'||'",
            TokenKind::Not => "'!'",
            TokenKind::Plus => "'+'",
            TokenKind::Minus => "'-'",
            TokenKind::Star => "'*'",
            TokenKind::Slash => "'/'",
            TokenKind::String => "string",
            TokenKind::Number => "number",
            TokenKind::ContextPath => "context path",
            TokenKind::Identifier => "identifier",
            TokenKind::ComponentName => "component name",
            TokenKind::LineComment => "comment",
            TokenKind::BlockComment => "comment",
            TokenKind::Newline => "newline",
            TokenKind::TextContent => "text content",
            TokenKind::Eof => "end of file",
        }
    }
}
